From 5cb46f6a664db913f0ef2bf8e929c3f8d8cbfc5b Mon Sep 17 00:00:00 2001
From: Tony Hutter <hutter2@llnl.gov>
Date: Wed, 9 Jan 2019 13:16:39 -0800
Subject: [PATCH] Linux 4.18 compat: Use ktime_get_coarse_real_ts64()

Newer kernels remove current_kernel_time64().  Use
ktime_get_coarse_real_ts64() in its place.

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Signed-off-by: Tony Hutter <hutter2@llnl.gov>
Closes #8258
---
 config/kernel-ktime_get_coarse_real_ts64.m4 | 18 ++++++++++++++++++
 config/kernel.m4                            |  1 +
 include/spl/sys/time.h                      | 12 ++++++++++++
 3 files changed, 31 insertions(+)
 create mode 100644 config/kernel-ktime_get_coarse_real_ts64.m4

diff --git a/config/kernel-ktime_get_coarse_real_ts64.m4 b/config/kernel-ktime_get_coarse_real_ts64.m4
new file mode 100644
index 00000000000..d6be8c4185a
--- /dev/null
+++ b/config/kernel-ktime_get_coarse_real_ts64.m4
@@ -0,0 +1,18 @@
+dnl #
+dnl # 4.18: ktime_get_coarse_real_ts64() added.  Use it in place of
+dnl # current_kernel_time64().
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_KTIME_GET_COARSE_REAL_TS64],
+	[AC_MSG_CHECKING([whether ktime_get_coarse_real_ts64() exists])
+	ZFS_LINUX_TRY_COMPILE([
+		#include <linux/mm.h>
+	], [
+		struct timespec64 ts;
+		ktime_get_coarse_real_ts64(&ts);
+	], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_KTIME_GET_COARSE_REAL_TS64, 1, [ktime_get_coarse_real_ts64() exists])
+	], [
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel.m4 b/config/kernel.m4
index 7330c00e1bd..098c4370073 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -161,6 +161,7 @@ AC_DEFUN([ZFS_AC_CONFIG_KERNEL], [
 	ZFS_AC_KERNEL_ACL_HAS_REFCOUNT
 	ZFS_AC_KERNEL_USERNS_CAPABILITIES
 	ZFS_AC_KERNEL_IN_COMPAT_SYSCALL
+	ZFS_AC_KERNEL_KTIME_GET_COARSE_REAL_TS64
 
 	AS_IF([test "$LINUX_OBJ" != "$LINUX"], [
 		KERNEL_MAKE="$KERNEL_MAKE O=$LINUX_OBJ"
diff --git a/include/spl/sys/time.h b/include/spl/sys/time.h
index 1a986c9b97c..312415b7bc8 100644
--- a/include/spl/sys/time.h
+++ b/include/spl/sys/time.h
@@ -73,7 +73,13 @@ static inline void
 gethrestime(inode_timespec_t *ts)
 {
 #if defined(HAVE_INODE_TIMESPEC64_TIMES)
+
+#if defined(HAVE_KTIME_GET_COARSE_REAL_TS64)
+	ktime_get_coarse_real_ts64(ts);
+#else
 	*ts = current_kernel_time64();
+#endif /* HAVE_KTIME_GET_COARSE_REAL_TS64 */
+
 #else
 	*ts = current_kernel_time();
 #endif
@@ -83,7 +89,13 @@ static inline time_t
 gethrestime_sec(void)
 {
 #if defined(HAVE_INODE_TIMESPEC64_TIMES)
+#if defined(HAVE_KTIME_GET_COARSE_REAL_TS64)
+	inode_timespec_t ts;
+	ktime_get_coarse_real_ts64(&ts);
+#else
 	inode_timespec_t ts = current_kernel_time64();
+#endif  /* HAVE_KTIME_GET_COARSE_REAL_TS64 */
+
 #else
 	inode_timespec_t ts = current_kernel_time();
 #endif
From 77e50c3070a0009c4ed8b50dbb7cf0df48bdda90 Mon Sep 17 00:00:00 2001
From: Tony Hutter <hutter2@llnl.gov>
Date: Thu, 10 Jan 2019 11:03:40 -0800
Subject: [PATCH] Linux 5.0 compat: access_ok() drops 'type' parameter

access_ok no longer needs a 'type' parameter in the 5.0 kernel.

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Signed-off-by: Tony Hutter <hutter2@llnl.gov>
Closes #8261
---
 config/kernel-access-ok-type.m4 | 21 +++++++++++++++++++++
 config/kernel.m4                |  1 +
 include/linux/kmap_compat.h     |  8 ++++++++
 module/zcommon/zfs_uio.c        |  3 +--
 4 files changed, 31 insertions(+), 2 deletions(-)
 create mode 100644 config/kernel-access-ok-type.m4

diff --git a/config/kernel-access-ok-type.m4 b/config/kernel-access-ok-type.m4
new file mode 100644
index 00000000000..3b2878a55cb
--- /dev/null
+++ b/config/kernel-access-ok-type.m4
@@ -0,0 +1,21 @@
+dnl #
+dnl # Linux 5.0: access_ok() drops 'type' parameter:
+dnl #
+dnl # - access_ok(type, addr, size)
+dnl # + access_ok(addr, size)
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_ACCESS_OK_TYPE], [
+	AC_MSG_CHECKING([whether access_ok() has 'type' parameter])
+	ZFS_LINUX_TRY_COMPILE([
+		#include <linux/uaccess.h>
+	],[
+		const void __user __attribute__((unused)) *addr = (void *) 0xdeadbeef;
+		unsigned long __attribute__((unused)) size = 1;
+		int error __attribute__((unused)) = access_ok(0, addr, size);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_ACCESS_OK_TYPE, 1, [kernel has access_ok with 'type' parameter])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel.m4 b/config/kernel.m4
index 098c4370073..ea04d85b6cd 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -4,6 +4,7 @@ dnl #
 AC_DEFUN([ZFS_AC_CONFIG_KERNEL], [
 	ZFS_AC_KERNEL
 	ZFS_AC_QAT
+	ZFS_AC_KERNEL_ACCESS_OK_TYPE
 	ZFS_AC_TEST_MODULE
 	ZFS_AC_KERNEL_MISC_MINOR
 	ZFS_AC_KERNEL_OBJTOOL
diff --git a/include/linux/kmap_compat.h b/include/linux/kmap_compat.h
index 59ae566ce9d..b9c7f5bcc9d 100644
--- a/include/linux/kmap_compat.h
+++ b/include/linux/kmap_compat.h
@@ -27,6 +27,7 @@
 #define	_ZFS_KMAP_H
 
 #include <linux/highmem.h>
+#include <linux/uaccess.h>
 
 #ifdef HAVE_1ARG_KMAP_ATOMIC
 /* 2.6.37 API change */
@@ -37,4 +38,11 @@
 #define	zfs_kunmap_atomic(addr, km_type)	kunmap_atomic(addr, km_type)
 #endif
 
+/* 5.0 API change - no more 'type' argument for access_ok() */
+#ifdef HAVE_ACCESS_OK_TYPE
+#define	zfs_access_ok(type, addr, size)	access_ok(type, addr, size)
+#else
+#define	zfs_access_ok(type, addr, size)	access_ok(addr, size)
+#endif
+
 #endif	/* _ZFS_KMAP_H */
diff --git a/module/zcommon/zfs_uio.c b/module/zcommon/zfs_uio.c
index a2c1b5c3aaf..c1e31f51be0 100644
--- a/module/zcommon/zfs_uio.c
+++ b/module/zcommon/zfs_uio.c
@@ -81,11 +81,10 @@ uiomove_iov(void *p, size_t n, enum uio_rw rw, struct uio *uio)
 					return (EFAULT);
 			} else {
 				if (uio->uio_fault_disable) {
-					if (!access_ok(VERIFY_READ,
+					if (!zfs_access_ok(VERIFY_READ,
 					    (iov->iov_base + skip), cnt)) {
 						return (EFAULT);
 					}
-
 					pagefault_disable();
 					if (__copy_from_user_inatomic(p,
 					    (iov->iov_base + skip), cnt)) {
From 031cea17a3db1dae3b6968a8c71bcfb678a03235 Mon Sep 17 00:00:00 2001
From: Tony Hutter <hutter2@llnl.gov>
Date: Thu, 10 Jan 2019 14:28:10 -0800
Subject: [PATCH] Linux 5.0 compat: Use totalram_pages()

totalram_pages() was converted to an atomic variable in 5.0:

https://patchwork.kernel.org/patch/10652795/

Its value should now be read though the totalram_pages() helper
function.

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Signed-off-by: Tony Hutter <hutter2@llnl.gov>
Closes #8263
---
 config/kernel-totalram-pages-func.m4 | 18 ++++++++++++++++++
 config/kernel.m4                     |  1 +
 include/spl/sys/vmsystm.h            |  8 +++++++-
 module/zfs/arc.c                     |  4 ++--
 4 files changed, 28 insertions(+), 3 deletions(-)
 create mode 100644 config/kernel-totalram-pages-func.m4

diff --git a/config/kernel-totalram-pages-func.m4 b/config/kernel-totalram-pages-func.m4
new file mode 100644
index 00000000000..a6eac645431
--- /dev/null
+++ b/config/kernel-totalram-pages-func.m4
@@ -0,0 +1,18 @@
+dnl #
+dnl # Linux 5.0: totalram_pages is no longer a global variable, and must be
+dnl # read via the totalram_pages() helper function.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_TOTALRAM_PAGES_FUNC], [
+	AC_MSG_CHECKING([whether totalram_pages() exists])
+	ZFS_LINUX_TRY_COMPILE([
+		#include <linux/mm.h>
+	],[
+		unsigned long pages __attribute__ ((unused));
+		pages = totalram_pages();
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_TOTALRAM_PAGES_FUNC, 1, [kernel has totalram_pages()])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel.m4 b/config/kernel.m4
index ea04d85b6cd..e4d0e3393b6 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -163,6 +163,7 @@ AC_DEFUN([ZFS_AC_CONFIG_KERNEL], [
 	ZFS_AC_KERNEL_USERNS_CAPABILITIES
 	ZFS_AC_KERNEL_IN_COMPAT_SYSCALL
 	ZFS_AC_KERNEL_KTIME_GET_COARSE_REAL_TS64
+	ZFS_AC_KERNEL_TOTALRAM_PAGES_FUNC
 
 	AS_IF([test "$LINUX_OBJ" != "$LINUX"], [
 		KERNEL_MAKE="$KERNEL_MAKE O=$LINUX_OBJ"
diff --git a/include/spl/sys/vmsystm.h b/include/spl/sys/vmsystm.h
index 2b48fe0e369..6bdfc852ac0 100644
--- a/include/spl/sys/vmsystm.h
+++ b/include/spl/sys/vmsystm.h
@@ -33,8 +33,16 @@
 #include <sys/types.h>
 #include <asm/uaccess.h>
 
+#ifdef HAVE_TOTALRAM_PAGES_FUNC
+#define	zfs_totalram_pages	totalram_pages()
+#define	zfs_totalhigh_pages	totalhigh_pages()
+#else
+#define	zfs_totalram_pages	totalram_pages
+#define	zfs_totalhigh_pages	totalhigh_pages
+#endif
+
 #define	membar_producer()		smp_wmb()
-#define	physmem				totalram_pages
+#define	physmem				zfs_totalram_pages
 #define	freemem			(nr_free_pages() + \
 				global_page_state(NR_INACTIVE_FILE) + \
 				global_page_state(NR_INACTIVE_ANON) + \
diff --git a/module/zfs/arc.c b/module/zfs/arc.c
index 7e09633345d..f5d94cbf90a 100644
--- a/module/zfs/arc.c
+++ b/module/zfs/arc.c
@@ -4821,9 +4821,9 @@ arc_all_memory(void)
 {
 #ifdef _KERNEL
 #ifdef CONFIG_HIGHMEM
-	return (ptob(totalram_pages - totalhigh_pages));
+	return (ptob(zfs_totalram_pages - zfs_totalhigh_pages));
 #else
-	return (ptob(totalram_pages));
+	return (ptob(zfs_totalram_pages));
 #endif /* CONFIG_HIGHMEM */
 #else
 	return (ptob(physmem) / 2);
From 05805494dd7ea3b2fbb34ac031c338a8bc0bab62 Mon Sep 17 00:00:00 2001
From: Tony Hutter <hutter2@llnl.gov>
Date: Thu, 10 Jan 2019 15:28:44 -0800
Subject: [PATCH] Linux 5.0 compat: Convert MS_* macros to SB_*

In the 5.0 kernel, only the mount namespace code should use the MS_*
macos. Filesystems should use the SB_* ones.

https://patchwork.kernel.org/patch/10552493/

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Signed-off-by: Tony Hutter <hutter2@llnl.gov>
Closes #8264
---
 module/zfs/vdev_disk.c  |  3 ++-
 module/zfs/zfs_vfsops.c | 23 ++++++++++++-----------
 2 files changed, 14 insertions(+), 12 deletions(-)

diff --git a/module/zfs/vdev_disk.c b/module/zfs/vdev_disk.c
index d13f365dd05..c53a0aa0fcb 100644
--- a/module/zfs/vdev_disk.c
+++ b/module/zfs/vdev_disk.c
@@ -35,6 +35,7 @@
 #include <sys/zio.h>
 #include <linux/mod_compat.h>
 #include <linux/msdos_fs.h>
+#include <linux/vfs_compat.h>
 
 char *zfs_vdev_scheduler = VDEV_SCHEDULER;
 static void *zfs_vdev_holder = VDEV_HOLDER;
@@ -79,7 +80,7 @@ vdev_bdev_mode(int smode)
 	ASSERT3S(smode & (FREAD | FWRITE), !=, 0);
 
 	if ((smode & FREAD) && !(smode & FWRITE))
-		mode = MS_RDONLY;
+		mode = SB_RDONLY;
 
 	return (mode);
 }
diff --git a/module/zfs/zfs_vfsops.c b/module/zfs/zfs_vfsops.c
index c9e314caa22..766cbab7436 100644
--- a/module/zfs/zfs_vfsops.c
+++ b/module/zfs/zfs_vfsops.c
@@ -56,6 +56,7 @@
 #include <sys/dmu_objset.h>
 #include <sys/spa_boot.h>
 #include <sys/zpl.h>
+#include <linux/vfs_compat.h>
 #include "zfs_comutil.h"
 
 enum {
@@ -249,7 +250,7 @@ zfsvfs_parse_options(char *mntopts, vfs_t **vfsp)
 boolean_t
 zfs_is_readonly(zfsvfs_t *zfsvfs)
 {
-	return (!!(zfsvfs->z_sb->s_flags & MS_RDONLY));
+	return (!!(zfsvfs->z_sb->s_flags & SB_RDONLY));
 }
 
 /*ARGSUSED*/
@@ -336,15 +337,15 @@ acltype_changed_cb(void *arg, uint64_t newval)
 	switch (newval) {
 	case ZFS_ACLTYPE_OFF:
 		zfsvfs->z_acl_type = ZFS_ACLTYPE_OFF;
-		zfsvfs->z_sb->s_flags &= ~MS_POSIXACL;
+		zfsvfs->z_sb->s_flags &= ~SB_POSIXACL;
 		break;
 	case ZFS_ACLTYPE_POSIXACL:
 #ifdef CONFIG_FS_POSIX_ACL
 		zfsvfs->z_acl_type = ZFS_ACLTYPE_POSIXACL;
-		zfsvfs->z_sb->s_flags |= MS_POSIXACL;
+		zfsvfs->z_sb->s_flags |= SB_POSIXACL;
 #else
 		zfsvfs->z_acl_type = ZFS_ACLTYPE_OFF;
-		zfsvfs->z_sb->s_flags &= ~MS_POSIXACL;
+		zfsvfs->z_sb->s_flags &= ~SB_POSIXACL;
 #endif /* CONFIG_FS_POSIX_ACL */
 		break;
 	default:
@@ -373,9 +374,9 @@ readonly_changed_cb(void *arg, uint64_t newval)
 		return;
 
 	if (newval)
-		sb->s_flags |= MS_RDONLY;
+		sb->s_flags |= SB_RDONLY;
 	else
-		sb->s_flags &= ~MS_RDONLY;
+		sb->s_flags &= ~SB_RDONLY;
 }
 
 static void
@@ -403,9 +404,9 @@ nbmand_changed_cb(void *arg, uint64_t newval)
 		return;
 
 	if (newval == TRUE)
-		sb->s_flags |= MS_MANDLOCK;
+		sb->s_flags |= SB_MANDLOCK;
 	else
-		sb->s_flags &= ~MS_MANDLOCK;
+		sb->s_flags &= ~SB_MANDLOCK;
 }
 
 static void
@@ -1954,8 +1955,8 @@ zfs_remount(struct super_block *sb, int *flags, zfs_mnt_t *zm)
 	int error;
 
 	if ((issnap || !spa_writeable(dmu_objset_spa(zfsvfs->z_os))) &&
-	    !(*flags & MS_RDONLY)) {
-		*flags |= MS_RDONLY;
+	    !(*flags & SB_RDONLY)) {
+		*flags |= SB_RDONLY;
 		return (EROFS);
 	}
 
@@ -1963,7 +1964,7 @@ zfs_remount(struct super_block *sb, int *flags, zfs_mnt_t *zm)
 	if (error)
 		return (error);
 
-	if (!zfs_is_readonly(zfsvfs) && (*flags & MS_RDONLY))
+	if (!zfs_is_readonly(zfsvfs) && (*flags & SB_RDONLY))
 		txg_wait_synced(dmu_objset_pool(zfsvfs->z_os), 0);
 
 	zfs_unregister_callbacks(zfsvfs);
From ed158b19b1dddf26f2bbebb4d0fd21f04fdd5d38 Mon Sep 17 00:00:00 2001
From: Tony Hutter <hutter2@llnl.gov>
Date: Thu, 10 Jan 2019 17:07:05 -0800
Subject: [PATCH] Linux 5.0 compat: Fix SUBDIRs

SUBDIRs has been deprecated for a long time, and was finally removed in
the 5.0 kernel.  Use "M=" instead.

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Signed-off-by: Tony Hutter <hutter2@llnl.gov>
Closes #8257
---
 module/Makefile.in | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/module/Makefile.in b/module/Makefile.in
index 82d155dd31a..935bd266306 100644
--- a/module/Makefile.in
+++ b/module/Makefile.in
@@ -29,12 +29,12 @@ modules:
 	list='$(SUBDIR_TARGETS)'; for targetdir in $$list; do \
 		$(MAKE) -C $$targetdir; \
 	done
-	$(MAKE) -C @LINUX_OBJ@ SUBDIRS=`pwd` @KERNEL_MAKE@ CONFIG_ZFS=m $@
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` @KERNEL_MAKE@ CONFIG_ZFS=m $@
 
 clean:
 	@# Only cleanup the kernel build directories when CONFIG_KERNEL
 	@# is defined.  This indicates that kernel modules should be built.
-@CONFIG_KERNEL_TRUE@	$(MAKE) -C @LINUX_OBJ@ SUBDIRS=`pwd` @KERNEL_MAKE@ $@
+@CONFIG_KERNEL_TRUE@	$(MAKE) -C @LINUX_OBJ@ M=`pwd` @KERNEL_MAKE@ $@
 
 	if [ -f @LINUX_SYMBOLS@ ]; then $(RM) @LINUX_SYMBOLS@; fi
 	if [ -f Module.markers ]; then $(RM) Module.markers; fi
@@ -43,7 +43,7 @@ clean:
 
 modules_install:
 	@# Install the kernel modules
-	$(MAKE) -C @LINUX_OBJ@ SUBDIRS=`pwd` $@ \
+	$(MAKE) -C @LINUX_OBJ@ M=`pwd` $@ \
 		INSTALL_MOD_PATH=$(DESTDIR)$(INSTALL_MOD_PATH) \
 		INSTALL_MOD_DIR=$(INSTALL_MOD_DIR) \
 		KERNELRELEASE=@LINUX_VERSION@
From 0c593296e98e3ac95f14704e4cee6cedb2134990 Mon Sep 17 00:00:00 2001
From: Tony Hutter <hutter2@llnl.gov>
Date: Fri, 11 Jan 2019 18:01:28 -0800
Subject: [PATCH] Linux 5.0 compat: Disable vector instructions on 5.0+ kernels

The 5.0 kernel no longer exports the functions we need to do vector
(SSE/SSE2/SSE3/AVX...) instructions.  Disable vector-based checksum
algorithms when building against those kernels.

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Signed-off-by: Tony Hutter <hutter2@llnl.gov>
Closes #8259
---
 config/kernel-fpu.m4     |  41 ++++++++---
 include/linux/simd_x86.h | 142 ++++++++++++++++++++++++++++++---------
 2 files changed, 144 insertions(+), 39 deletions(-)

diff --git a/config/kernel-fpu.m4 b/config/kernel-fpu.m4
index 1c5690969d4..671fe7ea54e 100644
--- a/config/kernel-fpu.m4
+++ b/config/kernel-fpu.m4
@@ -1,18 +1,41 @@
+dnl # 
+dnl # Handle differences in kernel FPU code.
 dnl #
-dnl # 4.2 API change
-dnl # asm/i387.h is replaced by asm/fpu/api.h
+dnl # Kernel
+dnl # 5.0:	All kernel fpu functions are GPL only, so we can't use them.
+dnl #		(nothing defined)
+dnl #
+dnl # 4.2:	Use __kernel_fpu_{begin,end}()
+dnl #		HAVE_UNDERSCORE_KERNEL_FPU & KERNEL_EXPORTS_X86_FPU
+dnl #
+dnl # Pre-4.2:	Use kernel_fpu_{begin,end}()
+dnl #		HAVE_KERNEL_FPU & KERNEL_EXPORTS_X86_FPU
 dnl #
 AC_DEFUN([ZFS_AC_KERNEL_FPU], [
-	AC_MSG_CHECKING([whether asm/fpu/api.h exists])
+	AC_MSG_CHECKING([which kernel_fpu function to use])
 	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/kernel.h>
-		#include <asm/fpu/api.h>
+		#include <asm/i387.h>
+		#include <asm/xcr.h>
 	],[
-		__kernel_fpu_begin();
+		kernel_fpu_begin();
+		kernel_fpu_end();
 	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_FPU_API_H, 1, [kernel has <asm/fpu/api.h> interface])
+		AC_MSG_RESULT(kernel_fpu_*)
+		AC_DEFINE(HAVE_KERNEL_FPU, 1, [kernel has kernel_fpu_* functions])
+		AC_DEFINE(KERNEL_EXPORTS_X86_FPU, 1, [kernel exports FPU functions])
 	],[
-		AC_MSG_RESULT(no)
+		ZFS_LINUX_TRY_COMPILE([
+			#include <linux/kernel.h>
+			#include <asm/fpu/api.h>
+		],[
+			__kernel_fpu_begin();
+			__kernel_fpu_end();
+		],[
+			AC_MSG_RESULT(__kernel_fpu_*)
+			AC_DEFINE(HAVE_UNDERSCORE_KERNEL_FPU, 1, [kernel has __kernel_fpu_* functions])
+			AC_DEFINE(KERNEL_EXPORTS_X86_FPU, 1, [kernel exports FPU functions])
+		],[
+			AC_MSG_RESULT(not exported)
+		])
 	])
 ])
diff --git a/include/linux/simd_x86.h b/include/linux/simd_x86.h
index 10ce02e3746..5d6fbed35b9 100644
--- a/include/linux/simd_x86.h
+++ b/include/linux/simd_x86.h
@@ -81,7 +81,7 @@
 #endif
 
 #if defined(_KERNEL)
-#if defined(HAVE_FPU_API_H)
+#if defined(HAVE_UNDERSCORE_KERNEL_FPU)
 #include <asm/fpu/api.h>
 #include <asm/fpu/internal.h>
 #define	kfpu_begin()		\
@@ -94,12 +94,18 @@
 	__kernel_fpu_end();		\
 	preempt_enable();		\
 }
-#else
+#elif defined(HAVE_KERNEL_FPU)
 #include <asm/i387.h>
 #include <asm/xcr.h>
 #define	kfpu_begin()	kernel_fpu_begin()
 #define	kfpu_end()		kernel_fpu_end()
-#endif /* defined(HAVE_FPU_API_H) */
+#else
+/* Kernel doesn't export any kernel_fpu_* functions */
+#include <asm/fpu/internal.h>	/* For kernel xgetbv() */
+#define	kfpu_begin() 	panic("This code should never run")
+#define	kfpu_end() 	panic("This code should never run")
+#endif /* defined(HAVE_KERNEL_FPU) */
+
 #else
 /*
  * fpu dummy methods for userspace
@@ -286,11 +292,13 @@ __simd_state_enabled(const uint64_t state)
 	boolean_t has_osxsave;
 	uint64_t xcr0;
 
-#if defined(_KERNEL) && defined(X86_FEATURE_OSXSAVE)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_OSXSAVE) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_osxsave = !!boot_cpu_has(X86_FEATURE_OSXSAVE);
-#elif defined(_KERNEL) && !defined(X86_FEATURE_OSXSAVE)
-	has_osxsave = B_FALSE;
 #else
+	has_osxsave = B_FALSE;
+#endif
+#elif !defined(_KERNEL)
 	has_osxsave = __cpuid_has_osxsave();
 #endif
 
@@ -315,8 +323,12 @@ static inline boolean_t
 zfs_sse_available(void)
 {
 #if defined(_KERNEL)
+#if defined(KERNEL_EXPORTS_X86_FPU)
 	return (!!boot_cpu_has(X86_FEATURE_XMM));
 #else
+	return (B_FALSE);
+#endif
+#elif !defined(_KERNEL)
 	return (__cpuid_has_sse());
 #endif
 }
@@ -328,8 +340,12 @@ static inline boolean_t
 zfs_sse2_available(void)
 {
 #if defined(_KERNEL)
+#if defined(KERNEL_EXPORTS_X86_FPU)
 	return (!!boot_cpu_has(X86_FEATURE_XMM2));
 #else
+	return (B_FALSE);
+#endif
+#elif !defined(_KERNEL)
 	return (__cpuid_has_sse2());
 #endif
 }
@@ -341,8 +357,12 @@ static inline boolean_t
 zfs_sse3_available(void)
 {
 #if defined(_KERNEL)
+#if defined(KERNEL_EXPORTS_X86_FPU)
 	return (!!boot_cpu_has(X86_FEATURE_XMM3));
 #else
+	return (B_FALSE);
+#endif
+#elif !defined(_KERNEL)
 	return (__cpuid_has_sse3());
 #endif
 }
@@ -354,8 +374,12 @@ static inline boolean_t
 zfs_ssse3_available(void)
 {
 #if defined(_KERNEL)
+#if defined(KERNEL_EXPORTS_X86_FPU)
 	return (!!boot_cpu_has(X86_FEATURE_SSSE3));
 #else
+	return (B_FALSE);
+#endif
+#elif !defined(_KERNEL)
 	return (__cpuid_has_ssse3());
 #endif
 }
@@ -367,8 +391,12 @@ static inline boolean_t
 zfs_sse4_1_available(void)
 {
 #if defined(_KERNEL)
+#if defined(KERNEL_EXPORTS_X86_FPU)
 	return (!!boot_cpu_has(X86_FEATURE_XMM4_1));
 #else
+	return (B_FALSE);
+#endif
+#elif !defined(_KERNEL)
 	return (__cpuid_has_sse4_1());
 #endif
 }
@@ -380,8 +408,12 @@ static inline boolean_t
 zfs_sse4_2_available(void)
 {
 #if defined(_KERNEL)
+#if defined(KERNEL_EXPORTS_X86_FPU)
 	return (!!boot_cpu_has(X86_FEATURE_XMM4_2));
 #else
+	return (B_FALSE);
+#endif
+#elif !defined(_KERNEL)
 	return (__cpuid_has_sse4_2());
 #endif
 }
@@ -394,8 +426,12 @@ zfs_avx_available(void)
 {
 	boolean_t has_avx;
 #if defined(_KERNEL)
+#if defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx = !!boot_cpu_has(X86_FEATURE_AVX);
 #else
+	has_avx = B_FALSE;
+#endif
+#elif !defined(_KERNEL)
 	has_avx = __cpuid_has_avx();
 #endif
 
@@ -409,11 +445,13 @@ static inline boolean_t
 zfs_avx2_available(void)
 {
 	boolean_t has_avx2;
-#if defined(_KERNEL) && defined(X86_FEATURE_AVX2)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AVX2) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx2 = !!boot_cpu_has(X86_FEATURE_AVX2);
-#elif defined(_KERNEL) && !defined(X86_FEATURE_AVX2)
-	has_avx2 = B_FALSE;
 #else
+	has_avx2 = B_FALSE;
+#endif
+#elif !defined(_KERNEL)
 	has_avx2 = __cpuid_has_avx2();
 #endif
 
@@ -426,11 +464,13 @@ zfs_avx2_available(void)
 static inline boolean_t
 zfs_bmi1_available(void)
 {
-#if defined(_KERNEL) && defined(X86_FEATURE_BMI1)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_BMI1) && defined(KERNEL_EXPORTS_X86_FPU)
 	return (!!boot_cpu_has(X86_FEATURE_BMI1));
-#elif defined(_KERNEL) && !defined(X86_FEATURE_BMI1)
-	return (B_FALSE);
 #else
+	return (B_FALSE);
+#endif
+#elif !defined(_KERNEL)
 	return (__cpuid_has_bmi1());
 #endif
 }
@@ -441,11 +481,13 @@ zfs_bmi1_available(void)
 static inline boolean_t
 zfs_bmi2_available(void)
 {
-#if defined(_KERNEL) && defined(X86_FEATURE_BMI2)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_BMI2) && defined(KERNEL_EXPORTS_X86_FPU)
 	return (!!boot_cpu_has(X86_FEATURE_BMI2));
-#elif defined(_KERNEL) && !defined(X86_FEATURE_BMI2)
-	return (B_FALSE);
 #else
+	return (B_FALSE);
+#endif
+#elif !defined(_KERNEL)
 	return (__cpuid_has_bmi2());
 #endif
 }
@@ -456,11 +498,13 @@ zfs_bmi2_available(void)
 static inline boolean_t
 zfs_aes_available(void)
 {
-#if defined(_KERNEL) && defined(X86_FEATURE_AES)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AES) && defined(KERNEL_EXPORTS_X86_FPU)
 	return (!!boot_cpu_has(X86_FEATURE_AES));
-#elif defined(_KERNEL) && !defined(X86_FEATURE_AES)
-	return (B_FALSE);
 #else
+	return (B_FALSE);
+#endif
+#elif !defined(_KERNEL)
 	return (__cpuid_has_aes());
 #endif
 }
@@ -471,11 +515,13 @@ zfs_aes_available(void)
 static inline boolean_t
 zfs_pclmulqdq_available(void)
 {
-#if defined(_KERNEL) && defined(X86_FEATURE_PCLMULQDQ)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_PCLMULQDQ) && defined(KERNEL_EXPORTS_X86_FPU)
 	return (!!boot_cpu_has(X86_FEATURE_PCLMULQDQ));
-#elif defined(_KERNEL) && !defined(X86_FEATURE_PCLMULQDQ)
-	return (B_FALSE);
 #else
+	return (B_FALSE);
+#endif
+#elif !defined(_KERNEL)
 	return (__cpuid_has_pclmulqdq());
 #endif
 }
@@ -503,8 +549,12 @@ zfs_avx512f_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL) && defined(X86_FEATURE_AVX512F)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AVX512F) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx512 = !!boot_cpu_has(X86_FEATURE_AVX512F);
+#else
+	has_avx512 = B_FALSE;
+#endif
 #elif !defined(_KERNEL)
 	has_avx512 = __cpuid_has_avx512f();
 #endif
@@ -518,9 +568,13 @@ zfs_avx512cd_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL) && defined(X86_FEATURE_AVX512CD)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AVX512CD) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512CD);
+#else
+	has_avx512 = B_FALSE;
+#endif
 #elif !defined(_KERNEL)
 	has_avx512 = __cpuid_has_avx512cd();
 #endif
@@ -534,9 +588,13 @@ zfs_avx512er_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL) && defined(X86_FEATURE_AVX512ER)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AVX512ER) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512ER);
+#else
+	has_avx512 = B_FALSE;
+#endif
 #elif !defined(_KERNEL)
 	has_avx512 = __cpuid_has_avx512er();
 #endif
@@ -550,9 +608,13 @@ zfs_avx512pf_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL) && defined(X86_FEATURE_AVX512PF)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AVX512PF) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512PF);
+#else
+	has_avx512 = B_FALSE;
+#endif
 #elif !defined(_KERNEL)
 	has_avx512 = __cpuid_has_avx512pf();
 #endif
@@ -566,9 +628,13 @@ zfs_avx512bw_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL) && defined(X86_FEATURE_AVX512BW)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AVX512BW) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512BW);
+#else
+	has_avx512 = B_FALSE;
+#endif
 #elif !defined(_KERNEL)
 	has_avx512 = __cpuid_has_avx512bw();
 #endif
@@ -582,9 +648,13 @@ zfs_avx512dq_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL) && defined(X86_FEATURE_AVX512DQ)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AVX512DQ) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512DQ);
+#else
+	has_avx512 = B_FALSE;
+#endif
 #elif !defined(_KERNEL)
 	has_avx512 = __cpuid_has_avx512dq();
 #endif
@@ -598,9 +668,13 @@ zfs_avx512vl_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL) && defined(X86_FEATURE_AVX512VL)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AVX512VL) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512VL);
+#else
+	has_avx512 = B_FALSE;
+#endif
 #elif !defined(_KERNEL)
 	has_avx512 = __cpuid_has_avx512vl();
 #endif
@@ -614,9 +688,13 @@ zfs_avx512ifma_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL) && defined(X86_FEATURE_AVX512IFMA)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AVX512IFMA) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512IFMA);
+#else
+	has_avx512 = B_FALSE;
+#endif
 #elif !defined(_KERNEL)
 	has_avx512 = __cpuid_has_avx512ifma();
 #endif
@@ -630,9 +708,13 @@ zfs_avx512vbmi_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL) && defined(X86_FEATURE_AVX512VBMI)
+#if defined(_KERNEL)
+#if defined(X86_FEATURE_AVX512VBMI) && defined(KERNEL_EXPORTS_X86_FPU)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512VBMI);
+#else
+	has_avx512 = B_FALSE;
+#endif
 #elif !defined(_KERNEL)
 	has_avx512 = __cpuid_has_avx512f() &&
 	    __cpuid_has_avx512vbmi();
From 26a856594f731db62446cf537659f9360261fe97 Mon Sep 17 00:00:00 2001
From: Brian Behlendorf <behlendorf1@llnl.gov>
Date: Wed, 16 Jan 2019 10:39:19 -0800
Subject: [PATCH] Linux 5.0 compat: Fix bio_set_dev()

The Linux 5.0 kernel updated the bio_set_dev() macro so it calls the
GPL-only bio_associate_blkg() symbol thus inadvertently converting
the entire macro.  Provide a minimal version which always assigns the
request queue's root_blkg to the bio.

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Signed-off-by: Brian Behlendorf <behlendorf1@llnl.gov>
Closes #8287
---
 config/kernel-bio_set_dev.m4 | 35 +++++++++++++++++++++++++++++++++--
 module/zfs/vdev_disk.c       | 29 +++++++++++++++++++++++++++--
 2 files changed, 60 insertions(+), 4 deletions(-)

diff --git a/config/kernel-bio_set_dev.m4 b/config/kernel-bio_set_dev.m4
index 6be873c5615..71d47a89309 100644
--- a/config/kernel-bio_set_dev.m4
+++ b/config/kernel-bio_set_dev.m4
@@ -1,10 +1,10 @@
 dnl #
 dnl # Linux 4.14 API,
 dnl #
-dnl # The bio_set_dev() helper was introduced as part of the transition
+dnl # The bio_set_dev() helper macro was introduced as part of the transition
 dnl # to have struct gendisk in struct bio. 
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BIO_SET_DEV], [
+AC_DEFUN([ZFS_AC_KERNEL_BIO_SET_DEV_MACRO], [
 	AC_MSG_CHECKING([whether bio_set_dev() exists])
 	ZFS_LINUX_TRY_COMPILE([
 		#include <linux/bio.h>
@@ -20,3 +20,34 @@ AC_DEFUN([ZFS_AC_KERNEL_BIO_SET_DEV], [
 		AC_MSG_RESULT(no)
 	])
 ])
+
+dnl #
+dnl # Linux 5.0 API,
+dnl #
+dnl # The bio_set_dev() helper macro was updated to internally depend on
+dnl # bio_associate_blkg() symbol which is exported GPL-only.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_BIO_SET_DEV_GPL_ONLY], [
+	AC_MSG_CHECKING([whether bio_set_dev() is GPL-only])
+	ZFS_LINUX_TRY_COMPILE([
+		#include <linux/module.h>
+		#include <linux/bio.h>
+		#include <linux/fs.h>
+		MODULE_LICENSE("$ZFS_META_LICENSE");
+	],[
+		struct block_device *bdev = NULL;
+		struct bio *bio = NULL;
+		bio_set_dev(bio, bdev);
+	],[
+		AC_MSG_RESULT(no)
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_BIO_SET_DEV_GPL_ONLY, 1,
+		    [bio_set_dev() GPL-only])
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BIO_SET_DEV], [
+	ZFS_AC_KERNEL_BIO_SET_DEV_MACRO
+	ZFS_AC_KERNEL_BIO_SET_DEV_GPL_ONLY
+])
diff --git a/module/zfs/vdev_disk.c b/module/zfs/vdev_disk.c
index c53a0aa0fcb..db765c57bb3 100644
--- a/module/zfs/vdev_disk.c
+++ b/module/zfs/vdev_disk.c
@@ -513,13 +513,38 @@ vdev_submit_bio_impl(struct bio *bio)
 #endif
 }
 
-#ifndef HAVE_BIO_SET_DEV
+#ifdef HAVE_BIO_SET_DEV
+#if defined(CONFIG_BLK_CGROUP) && defined(HAVE_BIO_SET_DEV_GPL_ONLY)
+/*
+ * The Linux 5.0 kernel updated the bio_set_dev() macro so it calls the
+ * GPL-only bio_associate_blkg() symbol thus inadvertently converting
+ * the entire macro.  Provide a minimal version which always assigns the
+ * request queue's root_blkg to the bio.
+ */
+static inline void
+vdev_bio_associate_blkg(struct bio *bio)
+{
+	struct request_queue *q = bio->bi_disk->queue;
+
+	ASSERT3P(q, !=, NULL);
+	ASSERT3P(q->root_blkg, !=, NULL);
+	ASSERT3P(bio->bi_blkg, ==, NULL);
+
+	if (blkg_tryget(q->root_blkg))
+		bio->bi_blkg = q->root_blkg;
+}
+#define	bio_associate_blkg vdev_bio_associate_blkg
+#endif
+#else
+/*
+ * Provide a bio_set_dev() helper macro for pre-Linux 4.14 kernels.
+ */
 static inline void
 bio_set_dev(struct bio *bio, struct block_device *bdev)
 {
 	bio->bi_bdev = bdev;
 }
-#endif /* !HAVE_BIO_SET_DEV */
+#endif /* HAVE_BIO_SET_DEV */
 
 static inline void
 vdev_submit_bio(struct bio *bio)
